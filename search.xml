<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Beego 自定义过滤验证器]]></title>
    <url>%2F2019%2F04%2F24%2FBeego-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E9%AA%8C%E8%AF%81%E5%99%A8%2F</url>
    <content type="text"><![CDATA[验证器 一阶段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 部分正则表达式const ( RgxNumber = `\d+` RgxTelephone = "1[345789]\\d&#123;9&#125;" RgxPageSize = `([1-9][0-9]&#123;0,1&#125;|100)` //1-100 RgxAll = `[\s\S]*` RgxBool = `(true|false)` RgxAsc = `(asc|desc)` RgxBuildName = `[^请手动][\s\S]*` RgxNumberPositive = `[1-9]\d*$` //匹配正整数 RgxChinese = "[\u4e00-\u9fa5]+" // 匹配中文 RgxProvince = "[1-9]\\d&#123;5&#125;" RgxCity = RgxProvince RgxDistrict = RgxProvince RgxTown = "[1-9]\\d&#123;8&#125;" RgxVillage = "[1-9]\\d&#123;11&#125;" RgxTimestamp = "[1-9]\\d&#123;9&#125;")type Valid struct &#123; Rgx string Msg string Default interface&#123;&#125;&#125;type ValidRegister map[string]Validfunc (value ValidRegister) Comparison(data *url.Values) (err error) &#123; for k, v := range value &#123; // 遍历书写的过滤器 val, ok := (*data)[k] // 取出有设置验证的字段进行比对 if !ok &#123; // 有这个验证器 但是没有接受到这个参数 if v.Default == nil &#123; //且没有设置默认值 直接返回错误 return fmt.Errorf("[%s]必须存在 / 注释:%s", k, v.Msg) &#125; valueTemp, bl := v.Default.(string) if !bl &#123; return fmt.Errorf("默认值仅支持 (string) 类型") &#125; else &#123; // 将默认值添加到参数并直接返回不验证 (*data)[k] = []string&#123;valueTemp&#125; continue &#125; &#125; for j := 0; j &lt; len(val); j++ &#123; //因为接收到的参数以列表存在 所以进行遍历判断 if v.Rgx == "" &#123; v.Rgx = RgxAll &#125; rgx, err := regexp.Compile("^" + v.Rgx + "$") if err != nil &#123; beego.Debug(err) &#125; if !rgx.MatchString(val[j]) &#123; return fmt.Errorf("[%s]不符合格式 / 注释:%s", k, v.Msg) &#125; &#125; &#125; return nil&#125;// 验证数据并填充数据func (v ValidRegister) Validated(b *beego.Controller, validated ValidRegister) &#123; data := b.Input() //得到参数 if err := validated.Comparison(&amp;data); err != nil &#123; //如果错误则直接返回 b.Data["json"] = ControllerPageResponse&#123; Code: 100, Message: err.Error(), Data: "", &#125; b.ServeJSON() b.StopRun() &#125; //重新设置beego框架接收的参数 bTemp := b.Ctx.Input bTemp.ResetParams() for k, v := range data &#123; bTemp.SetParam(k, v[0]) &#125;&#125;//基础分页验证func BasePagiantion() ValidRegister &#123; return ValidRegister&#123; "page": Valid&#123; Default: "1", Rgx: RgxNumber, Msg: "仅支持数字 默认1", &#125;, "page_size": Valid&#123; Default: "10", Rgx: RgxPageSize, Msg: "默认10 每页数据量1-100条", &#125;, &#125;&#125; 控制器(具体实现参考beego)为公共的 BaseController 控制器添加 验证函数123func (b *BaseController) Validated(validated plugin.ValidRegister) &#123; b.Validator.Validated(&amp;b.Controller, validated)&#125; ResidentControlle 继承 BaseController的方法 并直接调用123456789func (this *ResidentController) Edit() &#123; this.Validated(plugin.ValidRegister&#123; &quot;user_id&quot;: plugin.Valid&#123; Default: &quot;0&quot;, Rgx: plugin.RgxNumberPositive, Msg: &quot;只能为数字&quot;, &#125;, &#125;&#125; 验证器 二阶段 加入多线程 并用通道接收错误 更加优雅的调用方式]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>beego</tag>
        <tag>vilidated</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言闭包]]></title>
    <url>%2F2019%2F04%2F24%2FGo%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包 环境(某些初始化操作 如定义变量) + 函数(返回一个函数用于后续调用)简单示例12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt")// 创建一个玩家生成器, 输入名称, 输出生成器func playerGen(name string) func() (string, int) &#123; // 血量一直为150 // 环境 hp := 150 // 返回创建的闭包 // 函数 return func() (string, int) &#123; // 将变量引用到闭包中 return name, hp &#125;&#125;func main() &#123; // 创建一个玩家生成器 // 在这里初始化了环境 generator := playerGen("high noon") // 执行该环境里的函数 // 返回玩家的名字和血量 name, hp := generator() // 打印值 fmt.Println(name, hp)&#125; 为什么用到这个查询数据库时经常要关联查询省市区代码数据 因为五级省市区数据大,关联性能严重下讲 如果每次重redis取数据 在大量地址相同的情况下性能些微影响 所以缓存到map中 123456789101112131415161718192021222324// 缓存读取省市区func (c *Cache) SetArea() func(string) string &#123; db2 := db.Sql().Model(models.Feipin_district2&#123;&#125;) //来自Gorm框架实例 areaMap := make(map[string]string) //初始化一个空的 map return func(code string) (name string) &#123; //这里返回一个闭包函数 if v, ok := areaMap[code]; !ok &#123; //如果map没有这个数据 则从缓存中读取并添加到map中 if str, err := c.GetCache(code); err == nil &#123;//从redis缓存读取 areaMap[code] = str return str &#125; else &#123;//map没有数据 且 缓存没有 则从数据库中查询添加到缓存中 area := models.Feipin_district2&#123;&#125; //初始化数据库结构体 if err := db2.Where("code=?", code).First(&amp;area).Error; err == nil &#123; name = area.Name areaMap[code] = name c.SetCache(code, name, 0) //添加到redis缓存 area = models.Feipin_district2&#123;&#125; return &#125; &#125; &#125; else &#123; 如果map有数据则直接返回 return v &#125; return &#125; 省市区结构体1234567type Feipin_district2 struct &#123; Id int64 Name string `description:"名称"` ParentId int64 `description:"上级id"` Code string `description:"码"` Level int64 `description:"层级"`&#125; 如何使用1234area := Cache&#123;&#125;.SetArea() //初始化这个闭包province := area("350000") //返回对应的中文city := area("350200") //返回对应的中文]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gorm</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言时间解析Json/Gorm框架解析]]></title>
    <url>%2F2019%2F04%2F20%2FGo%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E8%A7%A3%E6%9E%90Json-Gorm%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[用处 在对结构体进行编/解码的时候将国际时间转换成国内标准时间文本格式 在使用Gorm框架写入数据库的时候将 JSONTime解析成 time.Time 读取时将time.Time解析成JSONTime格式 接口何时会调用 UnmarshalJSON() &lt;- json.Unmarshal 解析到结构体 MarshalJSON() &lt;- json.Marshal 解析结构体到json Value() &lt;- gorm执行creat等创建操作 Scan() &lt;- gorm执行 find/first等查询操作 代码1 数据库字段为 timestamp 这里使用结构体的好处的可以拥有time.Time的方法 但不是必须的 12345678910111213141516171819202122232425262728293031323334353637const ( TimeFormat = "2006-01-02 15:04:05")type JSONTime struct &#123; time.Time&#125;func (t *JSONTime) UnmarshalJSON(data []byte) (err error) &#123; now, err := time.ParseInLocation(`"`+TimeFormat+`"`, string(data), time.Local) *t = JSONTime&#123; now, &#125; return&#125;func (t JSONTime) MarshalJSON() ([]byte, error) &#123; formatted := fmt.Sprintf("\"%s\"", t.Format(TimeFormat)) return []byte(formatted), nil&#125;func (t JSONTime) Value() (driver.Value, error) &#123; var zeroTime time.Time if t.Time.UnixNano() == zeroTime.UnixNano() &#123; return nil, nil &#125; return t.Time, nil&#125;func (t *JSONTime) Scan(v interface&#123;&#125;) error &#123; value, ok := v.(time.Time) if ok &#123; *t = JSONTime&#123;Time: value&#125; return nil &#125; return fmt.Errorf("can not convert %v to timestamp", v)&#125; 代码2 字段是整形时间戳 如:1498621052 1234567891011121314151617181920const ( TimeFormat = "2006-01-02 15:04:05" DayFormat = "2006-01-02")type TstampTime int64func (t *TstampTime) UnmarshalJSON(data []byte) (err error) &#123; time.ParseInLocation(`"`+TimeFormat+`"`, string(data), time.Local) return&#125;func (t TstampTime) MarshalJSON() ([]byte, error) &#123; tint := int64(t) if tint == 0 &#123; return []byte(`""`), nil &#125; tf := time.Unix(tint, 0).Format(`"` + TimeFormat + `"`) return []byte(tf), nil&#125; 代码1测试12345678910111213141516171819202122232425func main() &#123; type t struct &#123; Tm JSONTime `json:"tm"` //注意大写才能导出 &#125; t2 := new(t) standardTime := time.Now() //默认时间格式 fmt.Printf("系统默认的时间格式: %s \n", standardTime) t2.Tm = JSONTime&#123;standardTime&#125; bt, err := json.Marshal(t2) if err != nil &#123; return &#125; normalTime := string(bt) //常用显示 fmt.Printf("转成常用时间格式: %s \n", normalTime) err = json.Unmarshal([]byte(normalTime), t2) if err != nil &#123; return &#125; fmt.Printf("转换成系统默认格式: %s \n", t2.Tm)&#125; 输出系统默认的时间格式: 2019-04-20 20:30:05.44986 +0800 CST m=+0.000219042转成常用时间格式: {“tm”:”2019-04-20 20:30:05”}转换成系统默认格式: 2019-04-20 20:30:05 +0800 CST 代码2测试123456789101112131415161718192021222324type t struct &#123; Tm TstampTime&#125;t2 := &amp;t&#123; Tm: 1498621052,&#125;fmt.Printf("原始时间戳: %d \n", t2.Tm)bt, err := json.Marshal(t2)if err != nil &#123; return&#125;normalTime := string(bt) //常用显示fmt.Printf("转成常用时间格式: %s \n", normalTime)err = json.Unmarshal([]byte(normalTime), t2)if err != nil &#123; fmt.Println(err) return&#125;fmt.Printf("转换成时间戳格式: %d \n", t2.Tm) 输出 原始时间戳: 1498621052 转成常用时间格式: {“Tm”:”2017-06-28 11:37:32”} 转换成时间戳格式: 1498621052]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gorm</tag>
        <tag>time.Time</tag>
      </tags>
  </entry>
</search>
